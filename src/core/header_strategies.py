"""
Header Generation Strategies
=============================

Strategy Pattern implementations for different header generation modes.
Each strategy handles a specific header type and compression mode.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any
# PHASE 11: Import from renamed modules
from .header_config import HeaderConfig, HeaderStatistics


class HeaderStrategy(ABC):
    """
    Abstract base class for header generation strategies.

    Subclasses must implement:
    - generate(): Create header based on config
    - validate(): Verify header format
    """

    @abstractmethod
    def generate(self, config: HeaderConfig) -> str:
        """
        Generate header based on configuration

        Args:
            config: HeaderConfig object with strategy parameters

        Returns:
            Generated header string
        """
        pass

    @abstractmethod
    def validate(self, header: str) -> bool:
        """
        Validate generated header format

        Args:
            header: Header string to validate

        Returns:
            True if valid, False otherwise
        """
        pass

    def get_metadata(self) -> Dict[str, str]:
        """Get strategy metadata"""
        return {
            'strategy': self.__class__.__name__,
            'version': '1.0',
            'description': self.__doc__ or ''
        }


class NormalModeStrategy(HeaderStrategy):
    """
    Full dictionary + complete decompression instructions.

    Generates complete headers with all dictionary tables
    and detailed decompression instructions for AI systems.
    """

    def generate(self, config: HeaderConfig) -> str:
        """Generate full header with all dictionaries"""
        if config.dictionary_set == '1599':
            return self._build_normal_header_1599(config)
        elif config.dictionary_set == '2000':
            return self._build_normal_header_2000(config)
        else:
            return self._build_normal_header_default(config)

    def validate(self, header: str) -> bool:
        """Check header contains required decompression instructions"""
        required_patterns = [
            'DECOMPRESSION INSTRUCTIONS',
            'Dictionary',
            'Template',
        ]
        return all(pattern in header for pattern in required_patterns)

    def _build_normal_header_1599(self, config: HeaderConfig) -> str:
        """
        Build 1599-word dictionary header with FULL DICTIONARIES.

        PHASE 11 FIX: Now builds dictionaries dynamically from actual compressed content
        instead of using hard-coded values. This ensures headers match the compression.
        """
        # PHASE 11: Check if actual dictionaries are provided
        dictionaries = config.metadata.get('dictionaries')

        if dictionaries:
            # Use actual dictionaries from compressed content
            template_dict = dictionaries.get('template_dict', {})
            phrase_dict = dictionaries.get('phrase_dict', {})
            word_dict = dictionaries.get('word_dict', {})

            # Build template table from actual dicts
            template_lines = [f"{k}={v}" for k, v in sorted(template_dict.items())]
            template_table = '\n'.join(template_lines)

            # Build phrase table from actual dicts
            phrase_entries = [f"{k}={v}" for k, v in sorted(phrase_dict.items())]
            phrase_table = '|'.join(phrase_entries)

            # Build word table from actual dicts
            word_entries = [f"{k}={v}" for k, v in sorted(word_dict.items())]
            word_table = '|'.join(word_entries)

            template_count = len(template_dict)
            phrase_count = len(phrase_dict)
            word_count = len(word_dict)
        else:
            # Fallback to hard-coded dictionaries (backward compatibility)
            template_table = """T1=**üìú Constitutional Basis:**
T2=#### **üìú Constitutional Basis:**
T3=**üìä Implementation Standards:**
T4=#### **üìä Implementation Standards:**
T5=#### **üèóÔ∏è Quality Metrics:**
T6=**üèóÔ∏è Quality Metrics:**
T7=- **Success Indicators**:
T8=#### **üß† Visual Framework:**
T9=**üß† Visual Framework:**
T10=#### **üí° Practical Examples:**
T11=**üí° Practical Examples:**
T12=**üéØ Core Framework:**
T13=#### **üéØ Core Framework:**
T14=**üéØ Purpose & Usage:**
T15=#### **üéØ Core Verification Framework:**
T16=**üéØ Core Verification Framework:**
T17=- **Learning Integration**:
T18=- **Constitutional Compliance**:
T19=- **Configuration Management**:"""

            phrase_table = "‚Ç¨a=constitutional basis|‚Ç¨aa=traac adaptive reasoning framework|‚Ç¨ab=tumix constitutional multi|‚Ç¨ac=agent framework|‚Ç¨ad=rot constitutional thought graph system|‚Ç¨ae=quality control|‚Ç¨af=usage guidelines|‚Ç¨ag=mandatory requirements|‚Ç¨ah=user authority preservation|‚Ç¨ai=perspective analysis|‚Ç¨aj=principle evolution|‚Ç¨ak=constitutional foundation|‚Ç¨al=md absolute authority principle|‚Ç¨am=communication framework|‚Ç¨an=functional intent verification|‚Ç¨ao=awcloud system architecture|‚Ç¨ap=modal system architecture|‚Ç¨aq=development standards|‚Ç¨ar=verification framework|‚Ç¨as=depth calibration|‚Ç¨at=domain synthesis|‚Ç¨au=system integration|‚Ç¨av=constitutional compliance protocol|‚Ç¨aw=efficiency metrics|‚Ç¨ax=mandatory agents|‚Ç¨ay=perspective coverage|‚Ç¨az=accuracy improvement|‚Ç¨b=success indicators|‚Ç¨ba=systematic analysis|‚Ç¨bb=all previous principles|‚Ç¨bc=implementation examples|‚Ç¨bd=implementation feasibility|‚Ç¨be=security specialist|‚Ç¨bf=information integrity|‚Ç¨bg=internet verification|‚Ç¨bh=cognitive validation|‚Ç¨bi=complexity assessment|‚Ç¨c=quality metrics|‚Ç¨d=implementation standards|‚Ç¨e=visual framework|‚Ç¨f=constitutional compliance|‚Ç¨g=practical examples|‚Ç¨h=apply principle|‚Ç¨i=zero hallucination policy|‚Ç¨j=quality assurance|‚Ç¨k=level reasoning|‚Ç¨l=reference validation|‚Ç¨m=zero hallucination|‚Ç¨n=based systematic analysis|‚Ç¨o=document consistency|‚Ç¨p=continuous improvement|‚Ç¨q=technical domain expertise|‚Ç¨r=implementation methodology|‚Ç¨s=success patterns|‚Ç¨t=token reduction|‚Ç¨u=learning integration|‚Ç¨v=pattern recognition|‚Ç¨w=faster processing|‚Ç¨x=all core working principles|‚Ç¨y=core working principles|‚Ç¨z=cognitive chunking"

            word_table = "$#=CLAUDE.md|$A=user|$B=constitutional|$C=framework|$D=principle|$E=verification|$F=integration|$G=multi|$H=authority|$I=analysis|$J=core|$K=system|$L=validation|$M=template|$N=quality|$O=implementation|$P=metrics|$Q=security|$R=principles|$S=performance|$T=this|$U=domain|$V=technical|$W=traac|$X=article|$Y=reasoning|$Z=context|‡∏øa=with|‡∏øaa=complex|‡∏øab=expertise|‡∏øac=process|‡∏øad=expert|‡∏øae=appendix|‡∏øaf=working|‡∏øag=architecture|‡∏øah=systematic|‡∏øai=improvement|‡∏øaj=learning|‡∏øak=pattern|‡∏øal=step|‡∏øam=real|‡∏øan=agents|‡∏øao=reality|‡∏øap=management|‡∏øaq=protocol|‡∏øar=must|‡∏øas=collaboration|‡∏øat=depth|‡∏øau=efficiency|‡∏øav=decision|‡∏øaw=requirements|‡∏øax=indicators|‡∏øay=only|‡∏øaz=rate|‡∏øb=part|‡∏øba=level|‡∏øbb=drcc|‡∏øbc=accuracy|‡∏øbd=cognitive|‡∏øbe=task|‡∏øbf=before|‡∏øbg=perspective|‡∏øbh=examples|‡∏øbi=solution|‡∏øbj=assessment|‡∏øbk=reuse|‡∏øbl=faster|‡∏øbm=documentation|‡∏øbn=protocols|‡∏øbo=code|‡∏øbp=activation|‡∏øbq=templates|‡∏øbr=token|‡∏øbs=apply|‡∏øbt=mandatory|‡∏øbu=policy|‡∏øbv=continuous|‡∏øbw=first|‡∏øbx=from|‡∏øby=systems|‡∏øbz=verified|‡∏øc=zero|‡∏øca=identity|‡∏øcb=consistency|‡∏øcc=synthesis|‡∏øcd=purpose|‡∏øce=content|‡∏øcf=practical|‡∏øcg=internet|‡∏øch=requirement|‡∏øci=reduction|‡∏øcj=thai|‡∏øck=detection|‡∏øcl=self|‡∏øcm=compression|‡∏øcn=without|‡∏øco=information|‡∏øcp=project|‡∏øcq=anti|‡∏øcr=modal|‡∏øcs=specific|‡∏øct=mapping|‡∏øcu=expiration|‡∏øcv=approach|‡∏øcw=feedback|‡∏øcx=clear|‡∏øcy=problems|‡∏øcz=example|‡∏ød=patterns|‡∏øda=read|‡∏ødb=solutions|‡∏ødc=files|‡∏ødd=thought|‡∏øde=emergency|‡∏ødf=gitbook|‡∏ødg=method|‡∏ødh=critical|‡∏ødi=effectiveness|‡∏ødj=comprehensive|‡∏ødk=knowledge|‡∏ødl=verify|‡∏ødm=score|‡∏ødn=impact|‡∏ødo=organization|‡∏ødp=terms|‡∏ødq=recognition|‡∏ødr=path|‡∏øds=variable|‡∏ødt=adaptive|‡∏ødu=graph|‡∏ødv=awcloud|‡∏ødw=dynamic|‡∏ødx=tool|‡∏ødy=navigation|‡∏ødz=design|‡∏øe=based|‡∏øea=steps|‡∏øeb=testing|‡∏øec=processing|‡∏øed=time|‡∏øee=override|‡∏øef=immediate|‡∏øeg=sources|‡∏øeh=assistant|‡∏øei=english|‡∏øej=translation|‡∏øek=advanced|‡∏øel=viii|‡∏øem=functional|‡∏øen=assurance|‡∏øeo=methodology|‡∏øep=mind|‡∏øeq=references|‡∏øer=maintained|‡∏øes=database|‡∏øet=test|‡∏øeu=file|‡∏øev=risk|‡∏øew=speed|‡∏øex=frameworks|‡∏øey=codes|‡∏øez=corrections|‡∏øf=cross|‡∏øfa=role|‡∏øfb=duplication|‡∏øfc=configuration|‡∏øfd=websearch|‡∏øfe=structure|‡∏øff=absolute|‡∏øfg=philosophy|‡∏øfh=enhancement|‡∏øfi=development|‡∏øfj=adaptation|‡∏øfk=workflow|‡∏øfl=flow|‡∏øfm=confidence|‡∏øfn=audit|‡∏øfo=between|‡∏øfp=correct|‡∏øfq=request|‡∏øfr=behavior|‡∏øfs=simple|‡∏øft=gate|‡∏øfu=preservation|‡∏øfv=using|‡∏øfw=line|‡∏øfx=after|‡∏øfy=rule|‡∏øfz=architect|‡∏øg=basis|‡∏øga=json|‡∏øgb=paths|‡∏øgc=webfetch|‡∏øgd=config|‡∏øge=into|‡∏øgf=components|‡∏øgg=profile|‡∏øgh=communication|‡∏øgi=intent|‡∏øgj=mockup|‡∏øgk=persona|‡∏øgl=control|‡∏øgm=lifecycle|‡∏øgn=tree|‡∏øgo=summary|‡∏øgp=runtime|‡∏øgq=levels|‡∏øgr=tools|‡∏øgs=guidelines|‡∏øgt=tasks|‡∏øgu=requiring|‡∏øgv=ensure|‡∏øgw=follow|‡∏øgx=actions|‡∏øgy=metacognition|‡∏øgz=current|‡∏øh=compliance|‡∏øha=coverage|‡∏øhb=while|‡∏øhc=roles|‡∏øhd=layers|‡∏øhe=every|‡∏øhf=text|‡∏øhg=against|‡∏øhh=validate|‡∏øhi=maintain|‡∏øhj=rules|‡∏øhk=natural|‡∏øhl=developer|‡∏øhm=thinking|‡∏øhn=hybrid|‡∏øho=clarity|‡∏øhp=memory|‡∏øhq=enhanced|‡∏øhr=constraints|‡∏øhs=values|‡∏øht=meta|‡∏øhu=foundation|‡∏øhv=darkwingtm|‡∏øhw=complete|‡∏øhx=guessing|‡∏øhy=chunking|‡∏øhz=spacing|‡∏øi=agent|‡∏øia=challenge|‡∏øib=specifications|‡∏øic=active|‡∏øid=phrase|‡∏øie=join|‡∏øif=concepts|‡∏øig=checking|‡∏øih=identify|‡∏øii=reliability|‡∏øij=load|‡∏øik=responses|‡∏øil=used|‡∏øim=required|‡∏øin=across|‡∏øio=update|‡∏øip=specialist|‡∏øiq=count|‡∏øir=single|‡∏øis=strategy|‡∏øit=high|‡∏øiu=transparency|‡∏øiv=outdated|‡∏øiw=priority|‡∏øix=battle|‡∏øiy=insights|‡∏øiz=full|‡∏øj=rationale|‡∏øja=evidence|‡∏øjb=extraction|‡∏øjc=diagram|‡∏øjd=recurring|‡∏øje=compressed|‡∏øjf=default|‡∏øjg=assumptions|‡∏øjh=problem|‡∏øji=acceptance|‡∏øjj=debate|‡∏øjk=previous|‡∏øjl=cost|‡∏øjm=alignment|‡∏øjn=auditor|‡∏øjo=exploration|‡∏øjp=network|‡∏øjq=error|‡∏øjr=settings|‡∏øjs=thoughts|‡∏øjt=evolution|‡∏øju=names|‡∏øjv=scan|‡∏øjw=live|‡∏øjx=exception|‡∏øjy=foundational|‡∏øjz=research"

            template_count = 19
            phrase_count = 61
            word_count = 459

        # Build header with actual or fallback dictionaries
        header = f"""---
# üéØ **Dictionary-Compressed Context File**
**Platform: Claude Code(CLAUDE.md)**
**AI: Lossless dictionary compression. Load dictionaries below before processing content.**
**AI: Intelligent compression - AI achieves 100% comprehension through direct pattern recognition without decompression scripts.**
**AI: Comprehension - No decompression processing required.**

## üìñ **DECOMPRESSION INSTRUCTIONS**
**For AI Systems: Instant understanding via native code mapping - no processing required**

### **Step 1: Load Dictionary Tables**
**- Read all dictionary tables below into memory**
**- Template Dictionary**: T1-T{template_count} format(structural templates)
**- Phrase Dictionary**: ‚Ç¨a-‚Ç¨‚Ç¨bi format(multi-word phrases)
**- Word Dictionary**: $A-$V and ‡∏øa-‡∏ø‡∏øpq formats(single words)

### **Step 2: Apply Decompression**
**- Apply dictionaries in this order**
**1. Template Dictionary(T1-T{template_count})** - Replace template codes with full structures
**2. Phrase Dictionary(‚Ç¨a-‚Ç¨‚Ç¨bi)** - Replace phrase codes with complete phrases
**3. Word Dictionary($A-$V, ‡∏øa-‡∏ø‡∏øpq)** - Replace word codes with individual words

### **Step 3: Process Normally**
**- After decompression, the content is standard CLAUDE.md format - process as normal.**

#**‚ö†Ô∏è CRITICAL REMINDER:**
**- Designed for AI, NOT human reading**
**- Manual decompression = errors**
**- AI auto-decodes 100% accuracy and understand**
**- Humans: plain language only**
**- No codes/abbreviations with humans**
**- Use plain language only**
**- No ‚Ç¨ah-‚Ç¨ai, $D X, etc.**
**- Always explain clearly**
---

## üìö **DICTIONARY TABLES**

### **Template Dictionary({template_count} entries)**
```
{template_table}
```

### **Phrase Dictionary ({phrase_count} entries)**
```
{phrase_table}
```

### **Word Dictionary ({word_count}+ entries)**
```
{word_table}
```

---
"""
        return header

    def _build_normal_header_2000(self, config: HeaderConfig) -> str:
        """Build 2000-word dictionary header"""
        return self._build_normal_header_1599(config).replace('1599', '2000')

    def _build_normal_header_default(self, config: HeaderConfig) -> str:
        """Build default/minimal header"""
        return """# DECOMPRESSION INSTRUCTIONS
## Standard Header (Minimal Dictionary)

AI systems: Load dictionaries and decompress normally.
"""


class ZipModeStrategy(HeaderStrategy):
    """
    Minimal header + compression metadata only.

    For ZIP-compressed content, stores only metadata and
    decompression instructions. Dictionary tables are
    compressed inside ZIP, not displayed in header.
    """

    def generate(self, config: HeaderConfig) -> str:
        """Generate minimal zip-mode header"""
        header = f"""# ZIP-COMPRESSED CONTENT

**Compression**: Level {config.compression_level}
**Dictionary**: {'Full (1599)' if config.dictionary_set == '1599' else config.dictionary_set}
**Encoding**: base64 + gzip

## Decompression Instructions:

1. Decode from base64
2. Decompress with gzip
3. Load dictionaries from decompressed content
4. Apply dictionary replacements
5. Process as normal content

## Status:
‚úÖ Fully reversible
‚úÖ 100% data integrity
‚úÖ AI compatible
"""
        return header

    def validate(self, header: str) -> bool:
        """Check header has compression metadata"""
        return 'Compression:' in header or 'ZIP' in header


class CustomModeStrategy(HeaderStrategy):
    """
    User-defined header generation.

    Allows custom header content via metadata configuration.
    Useful for specialized deployment scenarios.
    """

    def generate(self, config: HeaderConfig) -> str:
        """Generate custom header from metadata"""
        if config.metadata and 'custom_content' in config.metadata:
            return config.metadata['custom_content']

        # Fallback to minimal header
        return """# CUSTOM HEADER

Custom header mode enabled.
Provide 'custom_content' in metadata for header generation.
"""

    def validate(self, header: str) -> bool:
        """Custom mode accepts any non-empty header"""
        return len(header) > 0


class StrategyRegistry:
    """
    Registry of available header strategies.

    Provides discovery and lookup of registered strategies.
    """

    _builtin_strategies = {
        'normal': NormalModeStrategy,
        'zip': ZipModeStrategy,
        'custom': CustomModeStrategy,
    }

    @classmethod
    def get_builtin_strategies(cls) -> Dict[str, type]:
        """Get all built-in strategies"""
        return cls._builtin_strategies.copy()

    @classmethod
    def describe_strategy(cls, name: str) -> Dict[str, Any]:
        """Get strategy description"""
        if name not in cls._builtin_strategies:
            return {}

        strategy_class = cls._builtin_strategies[name]
        instance = strategy_class()
        return {
            'name': name,
            'class': strategy_class.__name__,
            'docstring': strategy_class.__doc__,
            'metadata': instance.get_metadata(),
        }

    @classmethod
    def list_strategies(cls) -> list:
        """List all available strategy names"""
        return list(cls._builtin_strategies.keys())
